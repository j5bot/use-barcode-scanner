import { BarcodeFormat, BrowserMultiFormatReader } from "@zxing/browser";
import { DecodeHintType, Result } from '../types/zxing/library';
import { useCallback, useEffect, useRef, useState } from "react";

export type UseWebcamOptions = {
    hints?: Map<DecodeHintType, string[]>;
    preferDeviceLabelMatch?: RegExp;
};

type MediaDeviceInfoWithCapabilities = MediaDeviceInfo & MediaTrackCapabilities;

const defaultHints = new Map();
const barcodeFormats = [BarcodeFormat.EAN_13];
defaultHints.set(DecodeHintType.POSSIBLE_FORMATS, barcodeFormats);
defaultHints.set(DecodeHintType.TRY_HARDER, true);

const decodeFromVideo = async (codeReader: BrowserMultiFormatReader, element: HTMLVideoElement, deviceId?: string) => {
    return new Promise<Result>((resolve, reject) => {
        codeReader.decodeFromVideoDevice(deviceId ?? '', element, (result, err) => {
            if (!result) {
                return;
            }
            if (err) {
                console.log(err);
            }
            resolve(result);
        });
    });
};

export const useWebcam = (options: UseWebcamOptions) => {
    const {
        hints = defaultHints,
        preferDeviceLabelMatch,
    } = options;

    const webcamRef = useRef<HTMLVideoElement | null>(null);
    const codeReaderRef = useRef<BrowserMultiFormatReader>(new BrowserMultiFormatReader(hints));

    const [device, setDevice] = useState<MediaDeviceInfo>();
    const [devices, setDevices] = useState<MediaDeviceInfoWithCapabilities[]>();

    const [shouldReset, setShouldReset] = useState<boolean>(false);

    const listDevices = async (active: boolean) => {
        if (!active) {
            return;
        }
        try {
            await navigator.mediaDevices.getUserMedia({}).then();
        } catch (e) {
            // window.alert('error getting user media' + JSON.stringify(e));
        }
        const deviceList = await navigator.mediaDevices.enumerateDevices()
            .then(
                (devices) => devices
                    .filter((deviceInfo) => {
                        return deviceInfo.kind === 'videoinput';
                    })
                // .map((deviceInfo) => {
                //     // const capabilities = (deviceInfo as any).getCapabilities?.();
                //     // console.log(capabilities);
                //     // return {
                //     //     ...deviceInfo,
                //     //     ...(capabilities as MediaTrackCapabilities)
                //     // };
                // })
            );

        setDevices(deviceList);
        return deviceList;
    };

    const setPreferredDevice = (deviceList: MediaDeviceInfoWithCapabilities[] | undefined = devices) => {
        if (deviceList?.length === 0) {
            return;
        }
        const matchingDevice = deviceList?.find(device => preferDeviceLabelMatch?.test(device.label));
        const facingDevice = !matchingDevice && deviceList?.find(device => device?.facingMode?.includes('environment'));
        const defaultDevice = !(matchingDevice || facingDevice) ? devices?.[devices?.length - 1] : undefined;
        const deviceToUse = matchingDevice || facingDevice || defaultDevice;
        setDevice(deviceToUse);
        return deviceToUse;
    };

    useEffect(() => {
        let active = true;

        listDevices(active).then();
        return () => {
            active = false;
        };
    }, [shouldReset]);

    useEffect(() => {
        setPreferredDevice();
    }, [devices, setPreferredDevice]);

    // Returned getter functions
    const getCode = useCallback(async () => {
        let deviceToUse = device;
        if (!webcamRef.current) {
            console.log('lost ref to webcam');
            return;
        }
        // webcamRef.current.pause();

        if (!deviceToUse) {
            console.log('No webcam attached');

            codeReaderRef.current = new BrowserMultiFormatReader(hints);
            const deviceList = await listDevices(true);

            if (deviceList?.length === 0) {
                console.log('No device list found');
                return;
            }
            deviceToUse = setPreferredDevice(deviceList);

            if (!deviceToUse) {
                console.log('No device to use')
            }
        }
        return await decodeFromVideo(codeReaderRef.current, webcamRef.current, deviceToUse?.deviceId);
    }, [device]);

    const getDevices = () => devices;

    return {
        webcamRef,
        codeReaderRef,

        getCode,
        getDevices,

        setDevice,
        setShouldReset,
    };
};
